#labels OCR,LSTM
= Ocrocis =

Download the project as .tar.gz here: <http://cistern.cis.lmu.de/ocrocis.tar.gz>
 
* [Synopsis]
* [Installation]
* [How it works]
* [Step-by-step example]
* [Model application]
 
== Synopsis ==
 
_Ocrocis_ is a project manager interface for Thomas Breuel's _Ocropy_, a toolkit for training optical character recognition (OCR) models with long short term memory networks ([https://github.com/tmbdev/ocropy]).

 
_Ocrocis_ guides the user in training high-quality OCR models from raw PDFs or images. It features automatic project management with a minimalistic philosophy:

 
* Smart parameter inference, few required arguments
* Non-redundant disk usage via hardlinks
* Only core-Perl dependencies (aside _Ocropy_'s native dependencies')
 
----
 
Licensed 2015 under Apache 2.0 (

 
== Installation ==
 
=== Requirements ===
 
All systems:

 
* Manual installation: _Ocropy_, _Imagemagick_, _Perl &gt;= 5.14_, _perl-doc_, _groff_
* *Or* automatic installation: _Docker &gt;= 1.4.1_
 
_Ocrocis_ can be installed via _Docker_ which takes care of all dependencies, including those of _Ocropy_.

 
The idea of _Docker_ is to deliver pre-packaged containers of software that just need to be built and run.

 
==== How to get Docker ====
 
===== Linux =====
 
You can use your package manager to install _docker_ (or _docker.io_ in Ubuntu). _Docker_ is under heavy development (February 2015), so please make sure that you are installing a current version (1.4.1 as of Feb 2015).

 
If in doubt, install _Docker_ yourself, for example on _Ubuntu_:

 
[http://docs.docker.com/installation/ubuntulinux/]

 
===== Mac OS X =====
 
Install _Xcode_ ([https://itunes.apple.com/en/app/xcode/id497799835?mt=12]) and its command line tools:

 
{{{
{{{xcode-select --install}}}
}}}
 
Install the _Docker_ environment for _OS X_ (see [https://docs.docker.com/installation/mac/]). It is recommended to use the package manager _Homebrew_ ([http://brew.sh]):

 
{{{
{{{brew install Caskroom/cask/virtualbox docker boot2docker}}}
}}}
 
The following two instructions are given by the _boot2docker_ install routine and are repeated here for convenience. Let _launchd_ start _boot2docker_ at login and then load _boot2docker_:

 
{{{
{{{ln -sfv /usr/local/opt/boot2docker/*.plist ~/Library/LaunchAgents
launchctl load ~/Library/LaunchAgents/homebrew.mxcl.boot2docker.plist}}}
}}}
 
Finally, initialize, start and export _boot2docker_:

 
{{{
{{{boot2docker init
boot2docker start
$(boot2docker shellinit)}}}
}}}
 
The last two steps, {{{start}}} and {{{shellinit}}}, have to be repeated in each new shell you open. _Ocrocis_ will handle that for you, so you don't have to worry about it.

 
Now your _Docker_ should be ready to go on _OS X_. Test it like so:

 
{{{
{{{docker run hello-world}}}
}}}
 
==== How to get Ocropy for manual installation ====
 
See [https://github.com/tmbdev/ocropy].

 
Note that the manual installation of _Ocropy_ requires {{{sudo}}} privileges and is known to have some issues on _OS X_.

 
=== Installing Ocrocis ===
 
*With _Git_:* Clone and enter the repository like so:

 
{{{
{{{git clone git@gitlab.cis.uni-muenchen.de:ocr/ocrocis.git &amp;&amp; cd ocrocis}}}
}}}
 
*Without _Git_:* Download and unzip _Ocrocis_, then open your terminal and enter the installation directory.

 
In both cases, run the installation with your preferred installation method. There are two options:

 
# {{{./install with-docker}}} : builds the _Docker_ image and installs _Ocrocis_ as _Docker+Perl_ application.
# {{{./install perl-only}}} : installs _Ocrocis_ as Perl-only application. Use this method if you already have _Ocropy_ installed or want to install it manually.
 
Notes:

 
* You can re-run the installation with different methods as often as you want.
* If you have run _install with-docker_ several times, it is recommended to remove cached redundant _Docker_ images once in a while to free space: 
 * {{{./dockerclean}}}
 
== How it works ==
 
=== Workflow ===
 
There are five (and a half) commands:

 
* *Project initialization* 
 # {{{ocrocis convert}}} - convert a PDF file or a set of images to binary PNG images
 # {{{ocrocis burst}}} - segment each binary page image into a directory of line images
* *Iteration* 
 # {{{ocrocis next}}} - initialize the next project iteration
 # {{{ocrocis train}}} - prepare and run training
 # {{{ocrocis test}}} - prepare and run tests on annotated data
* *Model application* 
 # {{{ocrocis test --book}}} - run tests on unannotated data
 
Each command may or may not require some preparation (e.g. cropping images or annotating lines). See the documentation for further details.

 
*Output flow*

 
_Ocrocis_ itself is silent by default. All native _Ocropus_ output is printed to standard output for convenient logging (e.g. with {{{&gt; logfile.txt}}}).

 
Use {{{--verbose}}} to print verbose information to standard error ({{{2&gt;}}}).

 
=== Project architecture ===
 
*Data is structured*

 
_Ocrocis_ works on a fixed directory structure that allows it to efficiently manage the data generated in the training process:

 
* book repository with pages and line images
* iterations 
 * for each iteration: annotation set, annotation HTML, models
* training set
* test set
 
*Data is linked*

 
_Ocrocis_ uses hardlinks to consolidate data between the book repository, annotation sets, trainings sets and test sets. Data is always linked to its source directory, never copied. This avoids redundant disk usage.

 
There are two kinds of source directories:

 
# _book_: Original pages and line images, linked to by _annotation_, _training_ and _test_
# _annotation_ (for each iteration): Original ground truths, linked to by _training_ and _test_
 
The link structure is tree-like, analog to the directory structure, not chain-like. Each link points to the original data.

 
*Data is unique*

 
Changes to files (including links) anywhere in the link tree are reflected in the source directory. This is especially useful if you wish to modify the images (e.g. by cropping) at some iteration in the training process. The changes are reflected everywhere in the project.

 
*Data is safe*

 
The link structure also allows you to safely delete any link in the tree. The original data is kept, as long as there is still at least one link somewhere in the project. (Note that technically, the original data in _book_ are also just links.)

 
This tree shows a part of an example project with two pages used for training and testing.

 
{{{
{{{home
  ├── book
  │    ├── [original page images]
  │    ├── 0001
  │    │    └── [original line images]
  │    ├── 0002
  │    │    └── [original line images]
  │    └── ...
  │
  ├── iterations
  │    ├── 01
  │    │    ├── annotation
  │    │    │    ├── 0001
  │    │    │    │    ├── [links to line images in book]
  │    │    │    │    └── [original ground truths]
  │    │    │    ├── 0002
  │    │    │    │    ├── [links to line images in book]
  │    │    │    │    └── [original ground truths]
  │    │    │    └── ...
  │    │    ├── models
  │    │    │    └── [model files]
  │    │    └── index.html
  │    ├── 02
  │    │    └── ...
  │    └── ...
  │
  ├── training
  │    ├── 0001
  │    │    ├── [links to line images in book]
  │    │    └── [links to ground truths in annotation]
  │    └── ...
  │
  └── test
       ├── 0002
       │    ├── [links to line images in book]
       │    └── [links to ground truths in annotation]
       └── ...}}}
}}}
 
== Step-by-step example ==
 
This walkthrough shows how to train models from the demo PDF.

 
Please refer to the {{{--help}}} page of each command for references and further options, like using a specific model or several CPUs.

 
Note on *Pass-through options*: Each command takes one or more pass-through options as strings. These parameters are passed through unchanged to the underlying calls of _convert_ or _Ocropy_. For help on these options, please refer to their original documentations.

 
----
 
First, let's bootstrap the very first models. Create a directory named _demo_ and enter it:

 
{{{
mkdir demo &amp;&amp; cd demo
}}}
 
Download the demo PDF to the current project directory. This way you have access to it, even if you use _Docker_.

  
If you run _Ocrocis_ via _Docker_, the current directory is mounted into the _Docker_ container. This means you only have access to files in or below the current directory, not above.

  
{{{
wget http://cistern.cis.lmu.de/ocrocis/demo.pdf
}}}
 
----
 
*Step 1*: Convert the demo PDF to binary page images. This populates the {{{book}}} repository with binary page images:

 
{{{
ocrocis convert --verbose --pdf demo.pdf --convert &quot;-density 300&quot; --ocropus-nlbin &quot;-nochecks&quot;
}}}
 
----
 
*Step 2*: Burst each page image into a directory of line images:

 
{{{
ocrocis burst
}}}
 
----
 
*Step 3*: Initialize the next iteration with a subset of the page numbers in the {{{book}}} repository. This creates the first annotation set inside the {{{iterations/01/annotation}}} directory and populates it with links to the original line images for pages 1 and 2:

 
{{{
ocrocis next --verbose 1 2
}}}
 
From these, an annotation HTML is created as {{{iterations/01/annotations/Correction.html}}}. Open it with your favourite web browser, either by double-clicking on it within a file manager or via command line, like so:

 
{{{
firefox iterations/01/annotation/Correction.html
}}}
  
Safari on Mac OS X cannot save modifies HTML files. It is recommended to use Firefox or Chrome.

  
Annotate the ground truths inside the text fields, one for each line. Save the HTML file (with sources) as *the same file* via your browser's _Save as..._ feature.

 
----
 
*Step 4*: Run the training on a subset of the annotation set, in this case just page 1:

 
{{{
ocrocis train --verbose --ntrain 2000 --savefreq 1000 1
}}}
 
This command extracts the ground truths from the annotation HTML and saves them alongside the line images in the annotation set. It then creates the _training_ directory and populates it with links to line images and ground truths in the annotation set. It then starts training on the whole training set.

  
This command automatically reuses the latest model of the previous iteration as a starting point, if it exists.

  
----
 
*Step 5*: After training, you can expand the global test set and run an evaluation, e.g. of the latest model:

 
{{{
ocrocis test --verbose
}}}
 
This command automatically uses the remaining pages from the annotation set (here page 3). Just like {{{train}}}, it creates links in the global test set, pointing to line images and ground truths in the annotation set.

 
----
 
The test results will be quite bad due to the tiny training set. If you want to *continue training within the same iteration*, just run {{{train}}} again, this time with the last model as starting point:

 
{{{
ocrocis train --verbose --ntrain 2000 --savefreq 1000 --model iterations/01/models/model-00002000.pyrnn.gz 1
}}}
 
Note that each time you call {{{train}}} and {{{test}}}, the annotation HTML will be parsed for any changes and the ground truths will be updated. In other words, you may change the annotation HTML whenever you want and be sure that the changes are used in all subsequent runs.

 
----
 
*Step 5.x and beyond*: Repeat *steps 3 to 5* for several iterations, until the resulting models reach the desired quality. Each iteration will reuse the latest model from the previous iteration.

 
----
 
*Step 6*: If you want to apply a model on the whole {{{book}}} repository, use the {{{--book}}} switch. This command uses the latest model of the current project:

 
{{{
ocrocis test --book --verbose
}}}
 
For further information on model application, see the section below.

 
== Model application ==
 
This section explains how to apply a model on unknown (i.e. unannotated) pages and generate *only predictions* (no evaluations). Since this is a special case of testing, the {{{test}}} command is reused for this purpose.

 
==== Initialize new project ====
 
_Ocropus_ only works on binarized line images. Therefore, you first have to initialize a new project from the new pages via {{{convert}}} and {{{burst}}}.

 
Run {{{ocrocis convert --help}}} and {{{ocrocis burst --help}}} to see how to initialize a new project from PDFs or image files.

 
==== Apply model on project ====
 
Applying a model to a project works just like testing. Just skip the {{{next}}} and {{{train}}} commands and go right to the testing.

 
{{{ocrocis test --book --model [FILE] [OPTIONS] [PAGE-NUMBER...]}}}

 
The {{{--book}}} switch tells _Ocrocis_ that you want to test on the unannotated _book_ repository. Since it is unannotated, *only predictions* are computed, not evaluations.

 
All other options are the same as in testing (see {{{ocrocis test --help}}}).

  
If you do not specify the project home via {{{--home}}}, make sure you are within the newly initialized project directory.

   
If you use _Docker_, make sure the model you want to use is in the current directory or below. Copy it there if necessary.

   
If you do not specify an external model, a model from the same project is infered.

  
*Examples*

 
{{{
{{{ocrocis test --book
ocrocis test --book {1..3}
ocrocis test --book --verbose --model some-model-from-another-project.pyrnn.gz
ocrocis test --book --verbose --model iterations/02/models
ocrocis test --book --verbose --model iterations/02/models/model-00000010.pyrnn.gz
ocrocis test --book --verbose --model iterations/02/models/model-00000010.pyrnn.gz {1..3}}}}
}}}